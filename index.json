[{"categories":["tech"],"content":"最近重读《c程序设计语言》，把c语言捡起来。这篇文章总结c语言中容易遗忘或者混淆的基础细节，方便以后回顾。","date":"2022-08-23","objectID":"/c-review/","tags":["cpp"],"title":"《C程序设计语言》回顾","uri":"/c-review/"},{"categories":["tech"],"content":"前言： 最近重读《c程序设计语言》，把c语言重新捡起来。 这篇文章总结c语言中容易遗忘或者混淆的基础细节，方便以后回顾。 #include \u003cstdio.h\u003e c仅支持/*注释*/，c++引入// 注释。 所有变量都必须先声明后使用。定义在函数起始处，在任何执行语句之前。 while (fahr \u003c= upper)括号不能省。 宏定义：#define \u003c名字\u003e \u003c替换文本\u003e getchar()返回EOF(End Of File)标识文件结束。EOF与任何字符都不同。所以getchar()返回定义成int类型。 c语言惯例-紧凑风格： #include \u003cstdio.h\u003e main() { int c; while ((c = getchar()) != EOF) putchar(c); } long的长度：gcc下面的长度为32位，64位为64位；vc++下固定为32位。 字符常量，就是整数，如’A’，值为ascii码65。 a = b = c = 0;，赋值结合顺序是从右到左，a = (b = (c = 0))。 尽量使用标准库库函数。TODO：需要浏览一遍c库函数。 函数结构：int main(int argc, char **argv) { return 0; } unix惯例：返回0表示成功，返回非0表示失败。 c语言中，所有函数参数都是按值传递的。被调函数不能修改调用函数中变量的值，只能修改其私有的临时副本的值。 要修改调用函数的变量，可以使用指针，还是值传递。 getline把字符’\\0’插入数组末尾，标记字符串结束；c语言字符串约定。 自动变量，局部变量，外部变量，全局变量，静态变量，寄存器变量。 外部变量，自动初始化为0值；自动变量，不自动初始化。局部静态变量，仅初始化1次。 外部变量可以通过extern显式声明。 外部变量定义到.c中，在.h中用extern声明。 空参数列表用void表示。 不要过度使用全局变量，这会严重破坏程序的可读性。 所有整型char,short,int,long,long long都支持unsigned无符号和signed有符号。 有关这些类型长度定义的符号常量以及其他与机器和编译器有关的属性可以在标准头文件\u003climits.h\u003e和\u003cfloat.h\u003e中找到。 long类型用字母l或L结尾，无符号通常用字母u或U结尾。默认是int。 8进制，0开头；16进制，0x开头。字符转义：’\\ooo’，8进制转义，’\\xhh’，16进制转义。 ‘\\0’=0=NULL。 常量表达式，在编译期求值，可以用在常量出现的位置，如：数组长度。 字符串自动连接：\"hello \" \"world\"。 从技术角度看，字符串常量就是字符串数组，末尾以’\\0’结束。 枚举常量是另一种类型的常量：enum boolean {NO, YES}。 可匿名，仅本.c文件范围内可用。 用const限定符修饰变量，则变量初始化后不可修改。 const char *VSconst char *const !逻辑非运算符，将0转换为1，非0转换为0。 0=假，非0=真；c++ bool类型，false/true。 自动类型转换=隐式类型转换： 把\"比较窄的\"操作数转成\"比较宽的\"操作数，以不丢失信息。 针对可能丢失信息的表达式，编译器会给出警告。 signed会转换为unsigned，以大的为目标。 float转换为int，丢失小数部分。 double转换为float，截取还是四舍五入，依赖实现。 强制类型转换=显式类型转换，明确最好。 c语言没有规定char类型是unsigned还是signed。 i++vs++i：表达式的值 后加vs先加。 strcat(s, t)将字符串t拼接到s的尾部。strcat假定s中有足够的空间保存拼接后的结果。更安全的函数是strncat。 位运算符\u0026, |, ^(异或), \u003c\u003c, \u003e\u003e, ~(位取反)只能用于整型。 位置1：v |= bits 位置0：v \u0026= ~bits 判定位是否1：if (v \u0026 bits) 判定位是否0：if (v \u0026 bits == 0) 条件表达式=三元运算符：(a \u003e b) ? a : b c语言没有定义同一运算符中多个操作数的计算顺序，也没有定义函数参数的计算顺序；仅规定参数的副作用必须在函数调用之前生效； x = f() + g(); printf(\"%d %d\\n\", ++n, power(2, n)); 复合语句=程序块：{...}，语法上等价于单条语句。 表达式总以;结束；(go写习惯了，总是忘记;)。 switch ... case，默认fall through，比如显示break。 循环： while (condition) { // ... } do { // ... } while (condition); for (init; condition; step) { // ... } ,运算符，优先级最低。逗号分隔的多个表达式，从左到右依次求值，各表达式右边的操作数的类型和值即为其结果的类型和值。 for (i = 0, j = strlen(s) - 1; i \u003c j; i++, j--) c = s[i], s[i] = s[j], s[j] = c; 少用goto，难以维护。提前退出不算。 c语言中，省略返回值，则默认返回int(NOTE：不是void)；参数没标记类型，则默认认为是int。 同时定义变量+声明函数：double sum, atof(char []); c语言中，如果没有函数原型，则函数将在第一次出现的表达式中被隐式声明。 外部变量和函数的性质：通过一个名字对外部变量的所有引用，实际上都是引用同一个对象(外部链接)。 外部变量的声明和定义严格区分出来很重要。定义放在.c中，头文件中extern声明之，方便引用。 定义会分配存储单元；声明不会； 外部变量的初始化只能出现在其定义中； 预编译头文件：#include \u003c...\u003evs#include \"...\"；本质上就是文本展开； 前者在预设的lib头文件目录等处查找；后者仅在源文件位置查找； 仅加载一次：#ifndef xxx #define xxx #endif #pragma once static修饰全局变量，则只能本.c访问，不可再外部链接。 static修饰局部变量，初始化1次，保持结果下次使用。 register声明告诉编译器，该变量使用频率高。 由编译器决定是否真的放在寄存器中，所以该修饰符意义不大。 不可取地址。 局部变量(自动变量)可以重名，内部隐藏外部重名变量。尽量避免重名变量。 外部变量和静态变量，默认初始化为0值；自动变量和寄存器变量，默认不修改，即未定义。 外部变量和竞态变量初始化在程序开始之前，值必须是常量表达式，可编译期求解。 自动变量和寄存器变量，初始化可即时计算，不需要是常量表达式。 局部变量的数组，c语言中允许长度可变；c++不允许； 递归执行时消耗栈内存(参数入栈)，递归太深栈内存会耗尽。递归执行速度并不快，但代码比较紧凑。 递归实现注意跳出条件； 递归实现注意先定深度； 宏替换：#define dprint(expr) printf(#expr \" = %g\\n)\", expr 注意用好括号，避免错误； c++中建议使用内联； #undef取消宏定义 日志行号，只能通过宏定义实现； #if !defined(HDR) #define HDR ... #endif #if SYSTEM == SYSV ... #elif SYSTEM == BSD ... #else ... #endif #ifndef HDR #define HDR ... #endif 指针： int z[10]; int c = 0; int d = 0; p = \u0026c; d = *p; *p = 123; p = \u0026z[0]; p = z; ++*p; // c值++，等效(*p)++ p++; // p指向下一个元素 p[1] = 1; *(p+1) = 1; int test(char s1[], char *s2) // 参数定义，指针和数组等效 // p[-1]语法OK，但越界会宕机； alloc(), afree()在栈上分配\u0026释放内存。 c语言保证，0=NULL永远不是有效的数据地址。因此常用NULL作为返回值表示异常。 指针和整数不能互相转换，0=NULL除外。 NULL定义在\u003cstddef.h\u003e中。ptrdiff_t表示两个指针的带符号差值，不过我们往往使用size_t。strlen，sizeof等都返回size_t无符号整型。 定义数组和定义指针的差别：定义指针字符串，修改其所指字符串内容，行为未定义。 char s1[] = \"test1\"; char *s2 = \"test2\"; // 内容不可修改。 strcop, strncpy, strcmp, strncmp ... 二维数组：```char test[i][j]``；相当于i个元素的数组，元素是char t[j]类型。 f(int daytab[2][13]) {...} f(int daytab[][13]) {...} // 等效前者，数组元素个数无关紧要。 f(int (*daytab)[13]) {...} // 参数是个指针，指向int t[13]类型。 // 字符串数组初始化 char *name[] = {\"123\", \"456\", NULL}; char name[][15] = {\"123\",","date":"2022-08-23","objectID":"/c-review/:0:0","tags":["cpp"],"title":"《C程序设计语言》回顾","uri":"/c-review/"},{"categories":["tech"],"content":"这篇文章总结了关于lua容易犯错的各种细节，方便新同学了解，老同学回顾。避免踩坑，从你我做起。","date":"2022-08-23","objectID":"/lua-problems/","tags":["lua"],"title":"lua防坑指南","uri":"/lua-problems/"},{"categories":["tech"],"content":"前言 这是几年前总结lua坑的一篇东西，对lua新人会比较有用。 个人总结 计数的起点是1，而非0，在遍历时一定要记得这一点； #运算符查找1开始的连续元素个数。如果id不连续，那么#结果、遍历操作可能不符合预期； #运算符的结果与table.maxn的结果不一定一致；此外，table.maxn在5.2中被deprecated，不要用它； 数组中添加/删除元素，请使用table.insert(…)，table.remove(…)；请明白直接赋值nil的后果； #运算符可作用于任何metatable有__len域的对象； 模块编写，5.1.5/5.2/5.3都推荐使用reutrn module_table的方式，不要再使用module/package…； 使用local修饰所有变量或函数，避免污染全局名字空间；如果出现全局对象(未用local修饰)，请确定是你所期望的； lua中类似3元运算符的用法：a and b or c，注意：前提是b为真； lua中的与(and)/或(or)返回的是原对象，而非boolean值，同时支持短路求值(提前退出)，如：a or b or c，如果a为真，那么b/c不会参与计算，返回a对象； lua中取默认值的方式：a = a or {…}； 不同类型进行==比较，结果必定为假，如：3 == “3”；而导出函数中，lua_tonumber会自动进行类型转换，如果类型敏感需要先判断类型； lua_tostring/lua_tonumber会自动进行类型转换，这可能导致lua_next出错； lua赋值给c整型时，如果是非unsigned，必须result = (unsigned)lua_tointegor(L, idx)，否则可能与预期不一致，原因是超过result上限但在unsigned范围内的double数值赋值给result，和unsigined直接赋值给result表现并不一样(编译器相关)。譬如：lua中，c.member = 4194967296，member在lua中是int类型； lua仅保证其栈上有LUA_MINSTACK(20)个空间，如果需要用到超过该数值的栈空间，必须使用lua_checkstack扩展栈空间，否则崩溃； lua的堆栈平衡： 导出给lua用的函数，lua在调用函数前后会自动进行堆栈平衡；失败返回false可以用return 0代替； c中进行lua栈操作，且非直接导出给lua调用的，必须保证调用前后堆栈平衡：或者调用前后栈顶一致(失败往往如此处理), 或者仅多了一个插入的元素(调用该函数的目的)。成功/失败都必须符合预期，否则可能导致堆栈错乱，或者不断增长。 自动类型转换，以运算符前面的值类型为准：a = 1 + ‘1’; b = ‘1’ .. a。另，tostring()函数可作用于任何metatable有_ _tostring域的对象； lua中仅false和nil是假，其他一律真，包括0、’’、{}。这里强调一点：调用导出对象的函数，其返回值类型是bool或int判断成功与否方式是不一样的； for循环体内不要修改控制变量的值，该值会要参与下一元素遍历的计算； 循环体内不要删除元素，会导致不可预期的问题。可以记录id，再反序删除(减少元素id变化)； lua中字符串可以包含’\\0’;换句话说，lua中的字符串实际上就是一块内存，而lua_tolstring能拿到这块内存的起始地址与长度，lua中#运算符能拿到其长度； 浮点数比较不能直接用==，特别是/计算后的结果，应该比较差异绝对值*。虽然lua中只有一种数值类型，但并非所有相等判断都需要当作浮点数来进行； lua5.1中metatable的__gc事件只有full userdata会触发。lua5.2中table也会触发。5.1中想要监控table的gc，可以通过newproxy方法完成，该方法在5.2中删除； 对于userdata，其仅能在c中lua_setmetatable，lua层的setmetatable仅对table有效，对light/fulluserdata无效； fulluserdata是lua分配的一块内存，其生命周期有lua管理；lightuserdata仅保存一个指针，指针所指对象的生命周期由c进行管理；二者都通过lua_touserdata取得指针； math.random([m [, n]])： 无参数时，[0, 1) 1个参数时(仅支持整数，5.3下不是整数则出错)，[1, m] 2个参数时(仅支持整数，5.3下不是整数则出错)，[m, n] 代码执行之前，请先使用luac编译脚本为字节码，以进行语法检查；可配置到编辑器中，快捷执行； 他人总结 这篇blog也提到几个点，大家可以注意下(详细内容见blog内): for exp1, exp2, exp3 do \u003c执行体\u003e end 中, 三个表达式都是一次性求值. for 中的控制变量会被自动声明为局部变量, 并且仅在循环体内可见. 函数可以返回多个值, 只有函数作为表达式的最后一个值, 才能保留全部的返回值 补充，这里提到相应容易出错的场景： --代码一 local t = {} local item = myfunc() table.insert(t, item) item = nil --代码二 local t = {} table.insert(t, myfunc()) --行为可能不一致，请确定符合预期。 定义递归函数, 需要先声明, 后定义, 一定要分开写 loadstring 所加载的程序块是在全局作用于下执行的, 因此任何 local 变量都不能被 loadstring 的程序块所见 ","date":"2022-08-23","objectID":"/lua-problems/:0:0","tags":["lua"],"title":"lua防坑指南","uri":"/lua-problems/"},{"categories":null,"content":"刘冰，字旭曦，Beck Liu。 85年大叔，湖南湘潭人，现居广东珠海。 中南大学计科毕业，于金山、YY/虎牙、腾讯等公司任职(高级/资深)研发工程师。 历经端游、浏览器、小游戏、海外直播、信息流推荐与投放等项目，在软件研发\u0026架构领域有丰富经验。 当前对云原生、微服务、服务网格、分布式系统、流处理系统相关领域技术较有兴趣。 后台向技术栈，多年c/c++/go研发经验。 leetcode刷题新手…… 兴趣爱好不广泛…… 喜欢读书，五花八门、三教九流的书儿皆有浅尝。 打打游戏，lol菜鸡；喜欢玩艾尔登法环，但不喜欢被它玩。 每次健身坚持不过三个月。 想学摄影、钢琴，但到了周末就犯困。 欢迎来到github大型(同性)交友平台:)，欢迎各位阅读我的技术文章。 如果我的文章能给您带来一些启发或提示，那它们就物有所值了。 欢迎就各种技术问题来邮件探讨，邮箱：ice_ok@163.com 祝自己身体健康，工作开心，技术进步。 祝各位开发者们早日升职加薪迎娶白富美。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]